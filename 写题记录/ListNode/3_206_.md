# 206.Reserve Linked List

[🚀206 click here](https://leetcode.com/problems/reverse-linked-list/description/)

## Solution1️⃣(✌️Two Pointers Technique)

### 💻Code

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

 //Two Pointers Technique

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = new ListNode();

        while(cur != null){

            temp = cur.next;

            cur.next = pre;

            pre = cur;
            cur = temp;
        }
        return pre;

    }
}
```

## Solution2️⃣(🔁Recursion)

#### 📝My ideas

+ If we want to use Recursion, it always happens when some statements are repeatedly executed.
+ So we can make the statements become recursion.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

 //Recursion1️⃣(its logic is same to solution1️⃣)
class Solution {
    ListNode temp = new ListNode();

    public ListNode reverse(ListNode cur, ListNode pre){
        if(cur == null){
            return pre;
        }

        temp = cur.next;
        cur.next = pre;  //先翻转当前

        return reverse(temp, cur); //再继续翻转，相当于从前往后翻转
      
    }

    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }
}

 //Recursion2️⃣ 
//💡No external variables
class Solution {
    public ListNode reverseList(ListNode head) {
        
        if(head == null) return null;
        if(head.next == null) return head;
        
        ListNode newhead = reverseList(head.next); 
        head.next.next = head;
        head.next = null;  //相当于从后往前翻转

        return newhead;
        
    }
}

```

### 🤯My Confusions

#### [How to understand the `return` in recursion](./3_ReturnInRecursion.md)

#### My comprehension of **Solution2️⃣.Version2️⃣**

Different from Solution2️⃣.Version1️⃣, It need us consider from the end of the old link to the star.

<img src="C:\Users\savage\Documents\WeChat Files\wxid_fe3rhslse68l22\FileStorage\Temp\32a4930e0c07cb45102847b4e723198.jpg" alt="32a4930e0c07cb45102847b4e723198" style="zoom:80%;" />

### 💡Something I overlooked

1. I failed to take into account that **the edge cases (the linked list could be empty or the linked list may just have one node -- reflected in Solution2️⃣.Version2️⃣)** . But this case is already well covered in Solution1️⃣. So even my logic exists bugs, the program executed normally.
2. In Solution2️⃣, the reason why we consider the edge cases easily  is that we use `head.next` and `head.next.next`.