# 206.Reserve Linked List

[ğŸš€206 click here](https://leetcode.com/problems/reverse-linked-list/description/)

## Solution1ï¸âƒ£(âœŒï¸Two Pointers Technique)

### ğŸ’»Code

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

 //Two Pointers Technique

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = new ListNode();

        while(cur != null){

            temp = cur.next;

            cur.next = pre;

            pre = cur;
            cur = temp;
        }
        return pre;

    }
}
```

## Solution2ï¸âƒ£(ğŸ”Recursion)

#### ğŸ“My ideas

+ If we want to use Recursion, it always happens when some statements are repeatedly executed.
+ So we can make the statements become recursion.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

 //Recursion1ï¸âƒ£(its logic is same to solution1ï¸âƒ£)
class Solution {
    ListNode temp = new ListNode();

    public ListNode reverse(ListNode cur, ListNode pre){
        if(cur == null){
            return pre;
        }

        temp = cur.next;
        cur.next = pre;  //å…ˆç¿»è½¬å½“å‰

        return reverse(temp, cur); //å†ç»§ç»­ç¿»è½¬ï¼Œç›¸å½“äºä»å‰å¾€åç¿»è½¬
      
    }

    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }
}

 //Recursion2ï¸âƒ£ 
//ğŸ’¡No external variables
class Solution {
    public ListNode reverseList(ListNode head) {
        
        if(head == null) return null;
        if(head.next == null) return head;
        
        ListNode newhead = reverseList(head.next); 
        head.next.next = head;
        head.next = null;  //ç›¸å½“äºä»åå¾€å‰ç¿»è½¬

        return newhead;
        
    }
}

```

### ğŸ¤¯My Confusions

#### [How to understand the `return` in recursion](./3_ReturnInRecursion.md)

#### My comprehension of **Solution2ï¸âƒ£.Version2ï¸âƒ£**

Different from Solution2ï¸âƒ£.Version1ï¸âƒ£, It need us consider from the end of the old link to the star.

<img src="C:\Users\savage\Documents\WeChat Files\wxid_fe3rhslse68l22\FileStorage\Temp\32a4930e0c07cb45102847b4e723198.jpg" alt="32a4930e0c07cb45102847b4e723198" style="zoom:80%;" />

### ğŸ’¡Something I overlooked

1. I failed to take into account that **the edge cases (the linked list could be empty or the linked list may just have one node -- reflected in Solution2ï¸âƒ£.Version2ï¸âƒ£)** . But this case is already well covered in Solution1ï¸âƒ£. So even my logic exists bugs, the program executed normally.
2. In Solution2ï¸âƒ£, the reason why we consider the edge cases easily  is that we use `head.next` and `head.next.next`.