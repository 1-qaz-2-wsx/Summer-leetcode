# Remove Linked List Elements

[Question 203](https://leetcode.com/problems/remove-linked-list-elements/description/)

[Question 203ä¸­æ–‡]([203. ç§»é™¤é“¾è¡¨å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/remove-linked-list-elements/description/))

## idea

The following points should be considered when removing elements from a linked list:

+ If we want to remove, the linked list should not be empty.

  ```java
  head != null
  ```

+ If one of the elements is belong to the head, we have to deal with it specially. 

+ How about one of the elements is on the tail?

## Code Solution

### 1. remove directly

```java
/**time complexity O(n)
* space complexity O(1)
* @param head
* @param val
* @return 
*/

class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        while(head != null && head.val == val){
            head = head.next;
        }

        ListNode cur = head; // cur.next is the actual operation

        while(cur != null && cur.next != null){
            if(cur.next.val == val){
                cur.next = cur.next.next;
            }
            else{
                cur = cur.next;
            }
        }
        return head;
    }
}
```

#### ğŸ“ŒChallenges I Faced

1. **The first `while` loop uses `while` instead of `if`**
    because the updated `head.val` might still equal the target value and need to be removed again.

2. **The second `while` loop operates on `cur.next`**,
    so the condition is written as `cur.next != null` to ensure that the node being checked actually exists.

3. **How does `cur` change in the loop?**
    `cur` only advances (`cur = cur.next`) **when its next node is not deleted**.
    If `cur.next` is deleted, we do **not** move `cur` forward, because we still need to check the new `cur.next`.

1. ç¬¬ä¸€ä¸ªwhileå¾ªç¯ä¸æ˜¯ifï¼Œæ˜¯å› ä¸ºè€ƒè™‘åˆ°æ›´æ–°åçš„`head.val`ä»ç„¶éœ€è¦åˆ é™¤ã€‚
1. ç¬¬äºŒä¸ªwhileå¾ªç¯å®é™…å¤„ç†å¯¹è±¡æ˜¯`cur.next`ï¼Œæ‰€ä»¥åœ¨æ§åˆ¶å¾ªç¯æ¡ä»¶æ—¶ç”¨äº†`cur.next != null` ã€‚
1. å¾ªç¯ä½“å¤„ç†æ—¶`cur`åˆ°åº•æ€ä¹ˆæ”¹å˜ã€‚

### 2. Dummy node 

#### core idea

To avoid handing the head node separately, we can introduce a dummy node as the new head. This allows us to follow the unified approach throughout the entire operation. Btw, we don't have to hand the situation when the linked list has nothing.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {

        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode cur = dummy;

        while(cur.next != null){
            if(cur.next.val == val){
                cur.next = cur.next.next;
            }
            else{
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
```

### 3. Recursion

[I asked gpt about recursion space complexity(version cpp)](./SpaceComplexity)

```java
// version 1
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null){
            return head;
        }

        if(head.val == val){
            head = removeElements(head.next, val);
        }
        else{
           head.next = removeElements(head.next, val);
        }
        return head;
    }
}
```

```java
// version 2
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }

        head.next = removeElements(head.next, val);
        if (head.val == val) {
            return head.next;
        }
        return head;
    }
}
```

