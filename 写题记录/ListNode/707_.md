# 707.Desigh Linked List

[🔗707 click here](https://leetcode.com/problems/design-linked-list/description/)

## idea

+ Two solutions, one uses **singly linked list**, the other uses **doubly circular list with sentinel**, both of them uses **dummy node**.

## Solution 1

```java
class MyLinkedList { //singly linked list

    //define the node 
    class ListNode{
        int val;
        ListNode next;
        
        ListNode(int val){
            this.val = val;
        }
    }
    //the dummy head node
    private ListNode dummyhead;
    //the size of the linked list
    private int size; 

    public MyLinkedList() {
       this.size = 0;
       this.dummyhead = new ListNode(0); //is not invited in size
    }
    
    public int get(int index) {
        
        //check the validity of the index
        if(index >= size || index < 0){
            return -1;
        }

        //hand the valid index
        ListNode cur = dummyhead;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        return cur.next.val;
    }
    
    public void addAtHead(int val) {
        
        ListNode node = new ListNode(val);
        node.next = dummyhead.next;
        dummyhead.next = node;
        size++;

    }
    
    public void addAtTail(int val) {
        
        ListNode node = new ListNode(val);
        node.next = null;
        ListNode cur = dummyhead;
        for(int i = 0; i < size; i++){
            cur = cur.next;
        }
        //at this time cur is the tail because we use "size" not "its index"
        cur.next = node;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        
        if(index > size){
            return;
        }
        else if(index == size){
            addAtTail(val);
            return;
        }
        ListNode node = new ListNode(val);
        ListNode cur = dummyhead;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        node.next = cur.next;
        cur.next = node;
        size++;
    }
    
    public void deleteAtIndex(int index) {

        //check the validity of the index
        if(index >= size || index < 0){
            return;
        }

        ListNode cur = dummyhead;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 📌Challenges I Faced

+ Firstly check my mistake code👇

  ![image-20250807183501965](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807183501965.png)

  After analyzing, I found that the error lies in the following code:

  ![image-20250807193837998](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807193837998.png)

  👆I forgot `size--;` which can ensure the correctness of `size` to control the **loop frequency**.

+ If `size` is incorrect (e.g., larger than the actual number of nodes), then this loop will overshoot.

  `cur` will become `null`, and assigning `cur.next = node;` will throw a `NullPointerException`.

  Unlike arrays, linked lists don’t have bounds checking — so if your `size` variable is off, the traversal logic becomes dangerous and unstable.

+ It's better we use the following code instead:

  ![image-20250807194534353](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807194534353.png)

  👉 **But this doesn't mean everything is fine — the correct execution of the code still depends on the correctness of the logic. This only provides us with a safer way to control the loop.**

## Solution 2

#### 💡Solution 2 uses a doubly circular linked list, and [📄this document](./DoublyCircularList_Sentinel.md) provides a better explanation.

```java
class MyLinkedList {

    class ListNode{
        int val;
        ListNode prev;
        ListNode next;
        ListNode(){}
        ListNode(int val){
            this.val = val;
        }
    }

    int size;
    ListNode sentinel = new ListNode();
    //
    public MyLinkedList() {
        sentinel = new ListNode();
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
        size = 0;
    }
    
    public int get(int index) {
        if(index >= size || index < 0){
            return -1;
        }
        ListNode cur = sentinel;
        if(index >= size / 2){
            for(int i = 0; i < size - index; i++){
                cur = cur.prev;
            }
            return cur.val;
        }
        else{
            for(int i = 0; i < index; i++){
                cur = cur.next;
            }
            return cur.next.val;

        }

    }
    
    public void addAtHead(int val) {

        ListNode head = new ListNode(val);

        head.prev = sentinel;
        head.next = sentinel.next;  //attention please:the exchange order
        sentinel.next.prev = head;
        sentinel.next = head;
         
        size++;
        return;
    }
    
    public void addAtTail(int val) {
        ListNode tail = new ListNode(val);

        tail.prev = sentinel.prev;
        tail.next = sentinel;
        sentinel.prev.next = tail;
        sentinel.prev = tail;

        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index == size){
            addAtTail(val);
            return;
        }

        ListNode cur = sentinel;
        ListNode node = new ListNode(val);

        if(index >= size / 2){
            for(int i = 0; i < size - index; i++){
                cur = cur.prev;
            }
        }
        else{
            for(int i = 0; i < index; i++){
                cur = cur.next;
            }
            cur = cur.next;
        }
        node.prev = cur.prev;//先插新node的两根线，再改node左右两边的线
        node.next = cur;
        cur.prev.next = node;
        cur.prev = node;
        size++;
    }
    
    public void deleteAtIndex(int index) {

        if(index >= size) return;
        if(index < 0) return;

        ListNode cur = sentinel;
        if(index >= size / 2){
            for(int i = 0; i < size - index; i++){
                cur = cur.prev;
            }
        }
        else{
            for(int i = 0; i < index; i++){
                cur = cur.next;
            }
            cur = cur.next;
        }
        cur.prev.next = cur.next;
        cur.next.prev = cur.prev;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 🧠 Bug Analysis & Fix Record

#### 🧪One

+ check my code

  ![image-20250807211252637](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211252637.png)

  ![image-20250807211305054](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211305054.png)

+ After debugging, I found I have not **initialize** the linked list correctly:

  <img src="C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211445855.png" alt="image-20250807211445855" style="zoom:80%;" />

  The correct version is:

  <img src="C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211750955.png" alt="image-20250807211750955" style="zoom:80%;" />

#### 🧪Two

+ 🔍 look at the wrong answer and my incorrect code

  ![image-20250808100318083](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250808100318083.png)

+ ```java
  class MyLinkedList {
  
      class ListNode{
          int val;
          ListNode prev;
          ListNode next;
          ListNode(){}
          ListNode(int val){
              this.val = val;
          }
      }
  
      int size;
      ListNode sentinel = new ListNode();
      //
      public MyLinkedList() {
          sentinel = new ListNode();
          sentinel.prev = sentinel;
          sentinel.next = sentinel;
          size = 0;
      }
      
      public int get(int index) {
          if(index >= size || index < 0){
              return -1;
          }
          ListNode cur = sentinel;
          if(index >= size / 2){
              for(int i = 0; i < size - index; i++){
                  cur = cur.prev;
              }
              return cur.prev.val;
          }
          else{
              for(int i = 0; i < index; i++){
                  cur = cur.next;
              }
              return cur.next.val;
  
          }
  
      }
      
      public void addAtHead(int val) {
  
          ListNode head = new ListNode(val);
  
          head.prev = sentinel;
          head.next = sentinel.next;  //attention please:the exchange order
          sentinel.next.prev = head;
          sentinel.next = head;
           
          size++;
          return;
      }
      
      public void addAtTail(int val) {
          ListNode tail = new ListNode(val);
  
          tail.prev = sentinel.prev;
          tail.next = sentinel;
          sentinel.prev.next = tail;
          sentinel.prev = tail;
          
          size++;
      }
      
      public void addAtIndex(int index, int val) {
          if(index > size) return;
          if(index == size){
              addAtTail(val);
              return;
          }
          if(index < 0){
              index = 0;
          }
  
          ListNode cur = sentinel;
          ListNode node = new ListNode(val);
  
          if(index >= size / 2){
              for(int i = 0; i < size - index; i++){
                  cur = cur.prev;
              }
              cur = cur.prev;  
          }
          else{
              for(int i = 0; i < index; i++){
                  cur = cur.next;
              }
              cur = cur.next;
          }
          node.prev = cur.prev;//先插新node的两根线，再改node左右两边的线
          node.next = cur;
          cur.prev.next = node;
          cur.prev = node;
          size++;
      }
      
      public void deleteAtIndex(int index) {
          ListNode cur = sentinel;
          if(index >= size / 2){
              for(int i = 0; i < size - index; i++){
                  cur = cur.prev;
              }
              cur = cur.prev;  
          }
          else{
              for(int i = 0; i < index; i++){
                  cur = cur.next;
              }
              cur = cur.next;
          }
          cur.prev.next = cur.next;
          cur.next.prev = cur.prev;
          size--;
      }
  }
  
  /**
   * Your MyLinkedList object will be instantiated and called as such:
   * MyLinkedList obj = new MyLinkedList();
   * int param_1 = obj.get(index);
   * obj.addAtHead(val);
   * obj.addAtTail(val);
   * obj.addAtIndex(index,val);
   * obj.deleteAtIndex(index);
   */
  ```

+ Find where the code wrong?

+ 1. 从测试案例看，第一个`get`结果正确，第二个`get`结果有误。首先考虑是`deleteAtIndex`段代码处理有误。

     From the test case, the first `get` result is correct, but the second `get` result is wrong. The first suspect is the `deleteAtIndex` method.

  2. 分析`deleteAtIndex`段代码

     Analyzing the `deleteIndex` code segment

     ```java
     public void deleteAtIndex(int index) {
             ListNode cur = sentinel; 
             if(index >= size / 2){
                 for(int i = 0; i < size - index; i++){
                     cur = cur.prev;
                 }
                 cur = cur.prev;  //❌cur指向目标（index）的前项
             }
             else{
                 for(int i = 0; i < index; i++){
                     cur = cur.next;
                 }
                 cur = cur.next;  //✅cur指向目标（index）本身
             }
             cur.prev.next = cur.next; //✅此处的cur应该是目标（index）本身
             cur.next.prev = cur.prev;
             size--;
         }
     }
     ```

  3. ##### **问题原因**：遍历方向不同，但目标指针 `cur` 的结果处理不一致，导致删除错了节点。

     **Root cause**: Due to inconsistent handling of `cur` when traversing from different directions, the wrong node gets deleted.

  4. ##### ✅ **修改方式**：删除 `cur = cur.prev;` 这一行，使两种遍历方式都统一指向 index 节点本身。

     **Fix**: Delete the line `cur = cur.prev;`, so that in both branches `cur` points to the target node at `index`

  5. ❗ 后续测试中仍然失败，进一步排查发现 `get()` 方法中也存在同样的偏移问题，修正后测试通过。

     During further testing, errors persisted. Investigation revealed the same off-by-one issue in the `get()` method. After fixing it, all tests passed.