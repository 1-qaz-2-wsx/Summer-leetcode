# 707.Desigh Linked List

[ðŸ”—707 click here](https://leetcode.com/problems/design-linked-list/description/)

## idea

+ Two solutions, one uses **singly linked list**, the other uses **doubly circular list with sentinel**, both of them uses **dummy node**.

## Solution 1

```java
class MyLinkedList { //singly linked list

    //define the node 
    class ListNode{
        int val;
        ListNode next;
        
        ListNode(int val){
            this.val = val;
        }
    }
    //the dummy head node
    private ListNode dummyhead;
    //the size of the linked list
    private int size; 

    public MyLinkedList() {
       this.size = 0;
       this.dummyhead = new ListNode(0); //is not invited in size
    }
    
    public int get(int index) {
        
        //check the validity of the index
        if(index >= size || index < 0){
            return -1;
        }

        //hand the valid index
        ListNode cur = dummyhead;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        return cur.next.val;
    }
    
    public void addAtHead(int val) {
        
        ListNode node = new ListNode(val);
        node.next = dummyhead.next;
        dummyhead.next = node;
        size++;

    }
    
    public void addAtTail(int val) {
        
        ListNode node = new ListNode(val);
        node.next = null;
        ListNode cur = dummyhead;
        for(int i = 0; i < size; i++){
            cur = cur.next;
        }
        //at this time cur is the tail because we use "size" not "its index"
        cur.next = node;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        
        if(index > size){
            return;
        }
        else if(index == size){
            addAtTail(val);
            return;
        }
        ListNode node = new ListNode(val);
        ListNode cur = dummyhead;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        node.next = cur.next;
        cur.next = node;
        size++;
    }
    
    public void deleteAtIndex(int index) {

        //check the validity of the index
        if(index >= size || index < 0){
            return;
        }

        ListNode cur = dummyhead;
        for(int i = 0; i < index; i++){
            cur = cur.next;
        }
        cur.next = cur.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### ðŸ“ŒChallenges I Faced

+ Firstly check my mistake codeðŸ‘‡

  ![image-20250807183501965](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807183501965.png)

  After analyzing, I found that the error lies in the following code:

  ![image-20250807193837998](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807193837998.png)

  ðŸ‘†I forgot `size--;` which can ensure the correctness of `size` to control the **loop frequency**.

+ If `size` is incorrect (e.g., larger than the actual number of nodes), then this loop will overshoot.

  `cur` will become `null`, and assigning `cur.next = node;` will throw a `NullPointerException`.

  Unlike arrays, linked lists donâ€™t have bounds checking â€” so if your `size` variable is off, the traversal logic becomes dangerous and unstable.

+ It's better we use the following code instead:

  ![image-20250807194534353](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807194534353.png)

  ðŸ‘‰ **But this doesn't mean everything is fine â€” the correct execution of the code still depends on the correctness of the logic. This only provides us with a safer way to control the loop.**

## Solution 2

#### ðŸ’¡Solution 2 uses a doubly circular linked list, and [ðŸ“„this document](./DoublyCircularList_Sentinel.md) provides a better explanation.

```java
class MyLinkedList {

    class ListNode{
        int val;
        ListNode prev;
        ListNode next;
        ListNode(){}
        ListNode(int val){
            this.val = val;
        }
    }

    int size;
    ListNode sentinel = new ListNode();
    //
    public MyLinkedList() {
        sentinel = new ListNode();
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
        size = 0;
    }
    
    public int get(int index) {
        if(index >= size || index < 0){
            return -1;
        }
        ListNode cur = sentinel;
        if(index >= size / 2){
            for(int i = 0; i < size - index; i++){
                cur = cur.prev;
            }
            return cur.val;
        }
        else{
            for(int i = 0; i < index; i++){
                cur = cur.next;
            }
            return cur.next.val;

        }

    }
    
    public void addAtHead(int val) {

        ListNode head = new ListNode(val);

        head.prev = sentinel;
        head.next = sentinel.next;  //attention please:the exchange order
        sentinel.next.prev = head;
        sentinel.next = head;
         
        size++;
        return;
    }
    
    public void addAtTail(int val) {
        ListNode tail = new ListNode(val);

        tail.prev = sentinel.prev;
        tail.next = sentinel;
        sentinel.prev.next = tail;
        sentinel.prev = tail;

        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index == size){
            addAtTail(val);
            return;
        }

        ListNode cur = sentinel;
        ListNode node = new ListNode(val);

        if(index >= size / 2){
            for(int i = 0; i < size - index; i++){
                cur = cur.prev;
            }
        }
        else{
            for(int i = 0; i < index; i++){
                cur = cur.next;
            }
            cur = cur.next;
        }
        node.prev = cur.prev;//å…ˆæ’æ–°nodeçš„ä¸¤æ ¹çº¿ï¼Œå†æ”¹nodeå·¦å³ä¸¤è¾¹çš„çº¿
        node.next = cur;
        cur.prev.next = node;
        cur.prev = node;
        size++;
    }
    
    public void deleteAtIndex(int index) {

        if(index >= size) return;
        if(index < 0) return;

        ListNode cur = sentinel;
        if(index >= size / 2){
            for(int i = 0; i < size - index; i++){
                cur = cur.prev;
            }
        }
        else{
            for(int i = 0; i < index; i++){
                cur = cur.next;
            }
            cur = cur.next;
        }
        cur.prev.next = cur.next;
        cur.next.prev = cur.prev;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### ðŸ§  Bug Analysis & Fix Record

#### ðŸ§ªOne

+ check my code

  ![image-20250807211252637](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211252637.png)

  ![image-20250807211305054](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211305054.png)

+ After debugging, I found I have not **initialize** the linked list correctly:

  <img src="C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211445855.png" alt="image-20250807211445855" style="zoom:80%;" />

  The correct version is:

  <img src="C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250807211750955.png" alt="image-20250807211750955" style="zoom:80%;" />

#### ðŸ§ªTwo

+ ðŸ” look at the wrong answer and my incorrect code

  ![image-20250808100318083](C:\Users\savage\AppData\Roaming\Typora\typora-user-images\image-20250808100318083.png)

+ ```java
  class MyLinkedList {
  
      class ListNode{
          int val;
          ListNode prev;
          ListNode next;
          ListNode(){}
          ListNode(int val){
              this.val = val;
          }
      }
  
      int size;
      ListNode sentinel = new ListNode();
      //
      public MyLinkedList() {
          sentinel = new ListNode();
          sentinel.prev = sentinel;
          sentinel.next = sentinel;
          size = 0;
      }
      
      public int get(int index) {
          if(index >= size || index < 0){
              return -1;
          }
          ListNode cur = sentinel;
          if(index >= size / 2){
              for(int i = 0; i < size - index; i++){
                  cur = cur.prev;
              }
              return cur.prev.val;
          }
          else{
              for(int i = 0; i < index; i++){
                  cur = cur.next;
              }
              return cur.next.val;
  
          }
  
      }
      
      public void addAtHead(int val) {
  
          ListNode head = new ListNode(val);
  
          head.prev = sentinel;
          head.next = sentinel.next;  //attention please:the exchange order
          sentinel.next.prev = head;
          sentinel.next = head;
           
          size++;
          return;
      }
      
      public void addAtTail(int val) {
          ListNode tail = new ListNode(val);
  
          tail.prev = sentinel.prev;
          tail.next = sentinel;
          sentinel.prev.next = tail;
          sentinel.prev = tail;
          
          size++;
      }
      
      public void addAtIndex(int index, int val) {
          if(index > size) return;
          if(index == size){
              addAtTail(val);
              return;
          }
          if(index < 0){
              index = 0;
          }
  
          ListNode cur = sentinel;
          ListNode node = new ListNode(val);
  
          if(index >= size / 2){
              for(int i = 0; i < size - index; i++){
                  cur = cur.prev;
              }
              cur = cur.prev;  
          }
          else{
              for(int i = 0; i < index; i++){
                  cur = cur.next;
              }
              cur = cur.next;
          }
          node.prev = cur.prev;//å…ˆæ’æ–°nodeçš„ä¸¤æ ¹çº¿ï¼Œå†æ”¹nodeå·¦å³ä¸¤è¾¹çš„çº¿
          node.next = cur;
          cur.prev.next = node;
          cur.prev = node;
          size++;
      }
      
      public void deleteAtIndex(int index) {
          ListNode cur = sentinel;
          if(index >= size / 2){
              for(int i = 0; i < size - index; i++){
                  cur = cur.prev;
              }
              cur = cur.prev;  
          }
          else{
              for(int i = 0; i < index; i++){
                  cur = cur.next;
              }
              cur = cur.next;
          }
          cur.prev.next = cur.next;
          cur.next.prev = cur.prev;
          size--;
      }
  }
  
  /**
   * Your MyLinkedList object will be instantiated and called as such:
   * MyLinkedList obj = new MyLinkedList();
   * int param_1 = obj.get(index);
   * obj.addAtHead(val);
   * obj.addAtTail(val);
   * obj.addAtIndex(index,val);
   * obj.deleteAtIndex(index);
   */
  ```

+ Find where the code wrong?

+ 1. ä»Žæµ‹è¯•æ¡ˆä¾‹çœ‹ï¼Œç¬¬ä¸€ä¸ª`get`ç»“æžœæ­£ç¡®ï¼Œç¬¬äºŒä¸ª`get`ç»“æžœæœ‰è¯¯ã€‚é¦–å…ˆè€ƒè™‘æ˜¯`deleteAtIndex`æ®µä»£ç å¤„ç†æœ‰è¯¯ã€‚

     From the test case, the first `get` result is correct, but the second `get` result is wrong. The first suspect is the `deleteAtIndex` method.

  2. åˆ†æž`deleteAtIndex`æ®µä»£ç 

     Analyzing the `deleteIndex` code segment

     ```java
     public void deleteAtIndex(int index) {
             ListNode cur = sentinel; 
             if(index >= size / 2){
                 for(int i = 0; i < size - index; i++){
                     cur = cur.prev;
                 }
                 cur = cur.prev;  //âŒcuræŒ‡å‘ç›®æ ‡ï¼ˆindexï¼‰çš„å‰é¡¹
             }
             else{
                 for(int i = 0; i < index; i++){
                     cur = cur.next;
                 }
                 cur = cur.next;  //âœ…curæŒ‡å‘ç›®æ ‡ï¼ˆindexï¼‰æœ¬èº«
             }
             cur.prev.next = cur.next; //âœ…æ­¤å¤„çš„curåº”è¯¥æ˜¯ç›®æ ‡ï¼ˆindexï¼‰æœ¬èº«
             cur.next.prev = cur.prev;
             size--;
         }
     }
     ```

  3. ##### **é—®é¢˜åŽŸå› **ï¼šéåŽ†æ–¹å‘ä¸åŒï¼Œä½†ç›®æ ‡æŒ‡é’ˆ `cur` çš„ç»“æžœå¤„ç†ä¸ä¸€è‡´ï¼Œå¯¼è‡´åˆ é™¤é”™äº†èŠ‚ç‚¹ã€‚

     **Root cause**: Due to inconsistent handling of `cur` when traversing from different directions, the wrong node gets deleted.

  4. ##### âœ… **ä¿®æ”¹æ–¹å¼**ï¼šåˆ é™¤ `cur = cur.prev;` è¿™ä¸€è¡Œï¼Œä½¿ä¸¤ç§éåŽ†æ–¹å¼éƒ½ç»Ÿä¸€æŒ‡å‘ index èŠ‚ç‚¹æœ¬èº«ã€‚

     **Fix**: Delete the line `cur = cur.prev;`, so that in both branches `cur` points to the target node at `index`

  5. â— åŽç»­æµ‹è¯•ä¸­ä»ç„¶å¤±è´¥ï¼Œè¿›ä¸€æ­¥æŽ’æŸ¥å‘çŽ° `get()` æ–¹æ³•ä¸­ä¹Ÿå­˜åœ¨åŒæ ·çš„åç§»é—®é¢˜ï¼Œä¿®æ­£åŽæµ‹è¯•é€šè¿‡ã€‚

     During further testing, errors persisted. Investigation revealed the same off-by-one issue in the `get()` method. After fixing it, all tests passed.