# Remove Linked List Elements

[Question 203](https://leetcode.com/problems/remove-linked-list-elements/description/)

[Question 203中文]([203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/description/))

## idea

The following points should be considered when removing elements from a linked list:

+ If we want to remove, the linked list should not be empty.

  ```java
  head != null
  ```

+ If one of the elements is belong to the head, we have to deal with it specially. 

+ How about one of the elements is on the tail?

## Code Solution

### 1. remove directly

```java
/**time complexity O(n)
* space complexity O(1)
* @param head
* @param val
* @return 
*/

class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        while(head != null && head.val == val){
            head = head.next;
        }

        ListNode cur = head; // cur.next is the actual operation

        while(cur != null && cur.next != null){
            if(cur.next.val == val){
                cur.next = cur.next.next;
            }
            else{
                cur = cur.next;
            }
        }
        return head;
    }
}
```

#### 📌Challenges I Faced

1. **The first `while` loop uses `while` instead of `if`**
    because the updated `head.val` might still equal the target value and need to be removed again.

2. **The second `while` loop operates on `cur.next`**,
    so the condition is written as `cur.next != null` to ensure that the node being checked actually exists.

3. **How does `cur` change in the loop?**
    `cur` only advances (`cur = cur.next`) **when its next node is not deleted**.
    If `cur.next` is deleted, we do **not** move `cur` forward, because we still need to check the new `cur.next`.

1. 第一个while循环不是if，是因为考虑到更新后的`head.val`仍然需要删除。
1. 第二个while循环实际处理对象是`cur.next`，所以在控制循环条件时用了`cur.next != null` 。
1. 循环体处理时`cur`到底怎么改变。

### 2. Dummy node 

#### core idea

To avoid handing the head node separately, we can introduce a dummy node as the new head. This allows us to follow the unified approach throughout the entire operation. Btw, we don't have to hand the situation when the linked list has nothing.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {

        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode cur = dummy;

        while(cur.next != null){
            if(cur.next.val == val){
                cur.next = cur.next.next;
            }
            else{
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
```

### 3. Recursion

[I asked gpt about recursion space complexity(version cpp)](./SpaceComplexity)

```java
// version 1
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null){
            return head;
        }

        if(head.val == val){
            head = removeElements(head.next, val);
        }
        else{
           head.next = removeElements(head.next, val);
        }
        return head;
    }
}
```

```java
// version 2
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }

        head.next = removeElements(head.next, val);
        if (head.val == val) {
            return head.next;
        }
        return head;
    }
}
```

